# 总结设计模式的之间的管理

​	 **不要生搬硬套，根据业务场景选择**

​	 **不要把简单的事情搞复杂，设计模式是用来解决复杂问题的**

​	 **把复杂的问题变得简单起来，（总结利用好前人的经验）**

# 工厂模式：（创建型）

```mermaid
graph LR
原始社会[原始社会]--> 农耕社会[农耕社会]
农耕社会 --> 小作坊[小作坊]
小作坊--> 工厂[工厂]
工厂--> 流水线生产[流水线生产]
```

# Spring 中 ----BeanFacotry  生产出来 FactoryBean



# 单例模式：

​	 **通过技术手段保证整个系统运行阶段，只有一个实例**

### 场景：

- 配置文件
- 监控程序
- IOC 容器
- 日历

### 实现手段：

- 懒汉式
- 饿汉式
- 注册登记式
- 反序列化处理

### Spring 中最常用的  注册登记式

### 效率最高

##### 		内部类



# 原型模式：复制

​	 **Spring 中的对象原型，主要是为了配置信息能够被重复使用，而且互不干扰**

```xml
<Bean scope = "prototype">
    <list></list>
</Bean>
```

### 技术手段

- 实现 cloneable 重写 clone 方法
- 字节码操作来实现（效率最高）
- 通过反射机制来实现（Spring 中常用）



# 代理模式

### 应用场景

- 中介
- 换牛
- 经纪人

### 代码场景：

- 字节码增强
- 动态实现非侵入式编程

##### 完成一件事情：代理只参与某一部分的功能

### 技术手段：

- JKD Proxy
- Cglib
- AspectJ
- asm

	 ​	我们通过代码演示，自己摸拟实现了 JKD 动态代理底层



# 策略模式：

​	 **将一些固定的算然统一起来**

### 应用场景

- 旅游路线的选择
- 出行方式的选择

### 代码场景：

- 支付方式的选择

### 特点：

​	  **巧妙地避免了 if... else... 或者 switch 语句**



# 模板方法:

​	 **流程固定，某一个环节有差异**

### 应用场景：

- JDBCTemplate
- 工作流

### 代码场景

- 摸拟 Spring JdbcTemplate 的简单实现
- Spring-ORM - 单表操作不需要写一句 SQL



# 委派模式：

​	 **代理模式的特殊情况，全权代理**

### 应用场景：

- 项目经理
- Dispatcher

### 代码场景：

- Spring 中的 ServletDispatcher， Delegate 命名结尾的都是委派模式



# 适配器模式：

- 兼容
- 转换

### 应用场景：

- 一拖三转换头
- HDMI 转 VGA
- 编码和解码

### 代码场景

- 登陆，为了兼容旧系统的登陆功能，在老基础之上进行兼容编程

### Spring 中 以 Adapter 结尾的



# 装饰器模式：

委派 + 适配器

- 扩展
- 覆盖

is - a （同宗同源）

### 应用场景：

- I/O 流
- 数据源

### 代码：

- 用代码改造了一个旧的系统

### Spring 中 Dercoator 结尾 ， Weapper 结尾的



# 观察者模式：

​	 **针对于目标对象的一举一动，要得到一个反馈。**

### 应用场景：

- 事件监听
- 日志监听
- 短信通知

#### 代码场景：

- Listenter
- Monitor
- Observer

### Spring 中 Listener （通常会结合动态代理）





# 各设计模式对比及编程思想总结

| 设计模式                | 一句话归纳                                     |
| ----------------------- | ---------------------------------------------- |
| 工厂模式（Factory）     | 只对结果负责，不要三无产品                     |
| 单例模式（Singleton）   | 保证独一无二                                   |
| 适配器模式（Adapter）   | 需要一个转换头（兼容）                         |
| 装饰器模式（Decorator） | 需要包装，但不改变本质（同宗同源）             |
| 代理模式（Proxy）       | 办事要求人，所以找代理。                       |
| 观察者模式（Observer）  | 完成时通知我                                   |
| 策略模式（Startegy）    | 我行我素，达到目的就行。                       |
| 模板模式（Template）    | 流程表标准化，原料自己加。                     |
| 委派模式（Delegate）    | 干活是你的（普通员工），功劳是我的（项目经理） |
| 原型模式（Prototype）   | 拔一根猴毛，吹出千万个。                       |



# 编程思想

## Spring 中的编程思想

### AOP：面向切面编程，动态代理

- 动态代理只是AOP 的一种技术手段，AOP 只是一种编程思想

Aspect 切面

##### ==AOP图解.png==



![AOP图解.png](assets/AOP图解.png)



### OOP：封装、继承、多态（一切皆对象）



​	现象（关注技术细节，面向过程）

​	关心的事物之间的联系

#### 正确：用代码去描述这个世界

​	毛病：接到需求就是干!!



### BOP：Bean 与 Bean 之间的关系，不希望每次人为的重复管理，有程序来实现自动管理

​	 **Spring 开始就是自从 Bean 的管理开始的**

new 个不停，配置 Hibernate 的对象关系

配置 ORM 的时候，Teacher， Student



### IOC：控制反转：创建对象的控制权反转： 

​	 **new， 谁使用 谁 new**

​	 **有了 Spring 以后，所有的 Bean 都有 Spring 来 new, 所以才叫控制反转**

​	 **new 出来以后的对象需要统一管理起来，所以才有了 IOC 容器 （Map）**



### DI 技术：解决对象动态赋值的问题

​	 **动态的调用 getter、setter (采用反射)**

​	 **Spring 的加载步骤： 定位、载入、注册；再确定要不要初始化 Bean**



# 编程思想总结

| Spring 思想 | 应用场景（特点）                                             | 一句话归纳               |
| ----------- | ------------------------------------------------------------ | ------------------------ |
| AOP         | Aspect Oriented Programming（面向切面编程）<br />找出多个类中有一定规律的代码，开发时拆开，运行时再合并。<br />面向切面编程，即面向规则编程。 | 解耦，专人做专事         |
| OOP         | Object Oriented programming（面向对象编程）<br />归纳总结生活中一切事物 | 封装、继承、多态         |
| BOP         | Bean Oriented Programming（面向 Bean 编程）<br />面向 Bean （普通的 java 类）设计程序。 | 一切从 Bean 开始         |
| IOC         | Inversion of Control（控制反转）<br />将 new 对象的动作交给 Spring 管理，并由 Spring 保存已创建的对象（IOC容器） | 转交控制权（即控制反转） |
| DI/DL       | Dependency Injection（依赖注入）或者 Dependency Lookup（依赖查找）<br />依赖注入、依赖查找，Spring 不仅保存自己创建的对象，而且保存对象与对象之间的关系。<br />注入即复制，主要三种方式构造方法、set 方法、直接赋值。 | 先清理关系再赋值。       |



